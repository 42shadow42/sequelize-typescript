///<reference path="../typings/socket.io/socket.io.d.ts"/>

import express = require('express');
import Promise = require('bluebird');
import fs = require('fs');
import soap = require('soap');
import {Inject} from "di-ts";
import Namespace = SocketIO.Namespace;
import {SocketNamespace} from "../websockets/SocketNamespace";
import {ApiAbstract} from "./ApiAbstract";
import {CronService} from "../services/CronService";
import {EVSEService} from "../services/EVSEService";
import {UserService} from "../services/UserService";
import {BadRequestError} from "../errors/BadRequestError";
import {config} from "../config";
import {IApiRequest} from "../interfaces/IApiRequest";
import {ChargingLocationService} from "../services/ChargingLocationService";
import {LogService} from "../services/LogService";
import {ProviderService} from "../services/ProviderService";
import {UserChargingService} from "../services/UserChargingService";
import {UtilityService} from "../services/UtilityService";
import {PlugService} from "../services/PlugService";
import {ChargingFacilityService} from "../services/ChargingFacilityService";
import {db} from "../db";
import {logger} from "../logger";
const request = require('request');

@Inject
export class ApiV1 extends ApiAbstract {

  constructor(protected utilityService: UtilityService,
              protected cronService: CronService,
              protected evseService: EVSEService,
              protected providerService: ProviderService,
              protected plugService: PlugService,
              protected chargingLocationService: ChargingLocationService,
              protected chargingFaciliyService: ChargingFacilityService,
              protected logService: LogService,
              protected userChargingService: UserChargingService,
              protected userService: UserService) {

    super();

    this.cronService.scheduleEvseDataImport();
    this.cronService.scheduleEvseStatusImport();

    this.evseService.initEVSEStates(this.evseStates);
  }

  // REST implementations
  // ===============================


  getOutComingIp(req: express.Request, res: express.Response, next: any): void {

    request('http://icanhazip.com/', (error, response, body) => {
      if (!error && response.statusCode == 200) {

        res.send(body);
        return;
      }

      res.send(error);
    })
  }

  // User
  // -------------------------------

  /**
   * @api {post} /users Create User
   * @apiVersion 1.0.1
   * @apiGroup User
   * @apiDescription Creates an auto generated user or a normal one or simply authenticates via HBS
   *
   *
   * @apiParam {String} languageCode Code which specifies the users language.
   *
   * @apiParam {String} [providerId] Id of users provider.
   *
   * @apiParam {String} [evcoId]  evcoId of User.
   * @apiParam {String} [password]  password of User.
   *
   * @apiSuccessExample Success-Response:
   *      HTTP/1.1 200 OK
   *      {
   *        "registrationDate": "2016-08-23T07:12:28.000Z",
   *        "id": 4,
   *        "code": "f32c6bf0-6900-11e6-971e-7130308399f5",
   *        "isAutoGenerated": true,
   *        "languageCode": "de-DE",
   *        "token": "eyJ0eXAiOiJKV1....--e4huE"
   *      }
   *
   */
  createUser(req: express.Request, res: express.Response, next: any): void {

    const data = req.body;

    Promise.resolve()
      .then(() => this.checkRequiredParameters(data, ['languageCode']))
      .then(() => this.userService.registerOrAuthenticate(
        data.languageCode, data.providerId, data.evcoId, data.password))
      .then((user) => res.json(user))
      .catch(next)
    ;
  }

  /**
   * @api {put} /users/me Update User
   * @apiVersion 1.0.1
   * @apiGroup User
   * @apiDescription Updates the current authenticated user
   *
   *
   *
   * @apiSuccessExample Success-Response:
   *      HTTP/1.1 200 OK
   *
   */
  updateUser(req: IApiRequest, res: express.Response, next: any): void {

    const data = req.body;

    if ('newPassword' in data) {

      this.userService.updatePassword(req.user, data['newPassword'])
        .then(() => res.sendStatus(HttpStatus.OK))
        .catch(next);
    } else {

      this.userService.update(req.user, data)
        .then(() => res.sendStatus(HttpStatus.OK))
        .catch(next);
    }
  }

  /**
   * @api {post} /users/me/login Login From Auto Generated User
   * @apiVersion 1.0.1
   * @apiGroup User
   * @apiDescription Converts auto generated user to non auto generated user if possible
   *
   * @apiParam {String} [evcoId]  evcoId of User.
   * @apiParam {String} [password]  password of User.
   *
   * @apiSuccessExample Success-Response:
   *      HTTP/1.1 200 OK
   *      {
   *        "registrationDate": "2016-08-23T07:12:28.000Z",
   *        "id": 4,
   *        "code": "f32c6bf0-6900-11e6-971e-7130308399f5",
   *        "isAutoGenerated": true,
   *        "languageCode": "de-DE",
   *        "token": "eyJ0eXAiOiJKV1....--e4huE"
   *      }
   *
   */
  loginFromAutoGenerated(req: IApiRequest, res: express.Response, next: any): void {

    const data = req.body;

    Promise.resolve()
      .then(() => this.checkRequiredParameters(data, ['evcoId', 'password']))
      .then(() => this.userService.loginFromAutoGenerated(req.user.code, data.evcoId, data.password))
      .then((user) => res.json(user))
      .catch(next)
    ;
  }

  /**
   * @api {post} /users/auth Authenticate User
   * @apiVersion 1.0.1
   * @apiGroup User
   * @apiDescription Authenticates user by checking provided evcoId and password or provided code if
   *                 user is an auto generated user.
   *
   *
   * @apiParam {String} [code] code of user - only auto generated user has a code property.
   *
   * @apiParam {String} [evcoId]  evcoId of User.
   * @apiParam {String} [password]  password of User.
   *
   * @apiSuccessExample Success-Response:
   *      HTTP/1.1 200 OK
   *      {
   *        "registrationDate": "2016-08-23T07:12:28.000Z",
   *        "id": 4,
   *        "code": "f32c6bf0-6900-11e6-971e-7130308399f5",
   *        "isAutoGenerated": true,
   *        "languageCode": "de-DE",
   *        "token": "eyJ0eXAiOiJKV1....--e4huE"
   *      }
   *
   */
  authUser(req: express.Request, res: express.Response, next: any): void {

    const data = req.body;

    Promise.resolve()
      .then(() => {

        if (!data.code && !data.evcoId && !data.password) {

          throw new BadRequestError('Both evcoId and password should be provided ' +
            'or code')
        }
      })
      .then(() => this.userService.getFullUser(data.evcoId || data.code))
      .then(user => this.userService.authenticate(user, data.password))
      .then((user) => res.json(user))
      .catch(next)
    ;
  }

  /**
   * @api {post} /users/me/chargings Create UserCharging
   * @apiVersion 1.0.1
   * @apiGroup User
   * @apiDescription Creates and stores a user charging object.
   *
   *
   * @apiParam {String} evseId id of EVSE entity.
   * @apiParam {String} session  session id of charging process.
   * @apiParam {String} startedAt  time of started charging process.
   *
   * @apiSuccessExample Success-Response:
   *      HTTP/1.1 200 OK
   *      {
   *        "id": 212,
   *        "evseId": "+33*822*009017757*1",
   *        "session": "49f66ccf-0a99-5594-1288-1c0027d06b26",
   *        "startedAt": "2016-09-29T13:36:53.089Z",
   *        "stoppedAt": null
   *      }
   *
   */
  createUserCharging(req: IApiRequest, res: express.Response, next: any): void {

    const data = req.body;

    Promise.resolve()
      .then(() => this.checkRequiredParameters(data, ['evseId', 'session', 'startedAt']))
      .then(() => this.userChargingService.createCharging(req.user.id, data.evseId, data.session, data.startedAt))
      .then(charging => res.json(charging))
      .catch(next)
    ;
  }

  /**
   * @api {get} /users/me/chargings Get UserChargings
   * @apiVersion 1.0.1
   * @apiGroup User
   * @apiDescription Returns all charging entities of currently authenticated user.
   *
   *
   * @apiSuccessExample Success-Response:
   *      HTTP/1.1 200 OK
   *      [
   *        {
   *          "id": 1,
   *          "userId": 2,
   *          "evseId": "DE*BER*E0001*01",
   *          "session": "eb6c99ff-0a88-1296-730f-e7bfe6f53662",
   *          "startedAt": "2016-09-02T15:03:03.000Z",
   *          "stoppedAt": "2016-09-02T15:05:03.000Z"
   *        },
   *        {
   *          "id": 2,
   *          "userId": 2,
   *          "evseId": "DE*BER*E0001*01",
   *          "session": "eb74d0f0-0a88-1295-6a80-e7c5f1e37d4c",
   *          "startedAt": "2016-09-02T15:12:00.000Z",
   *          "stoppedAt": "2016-09-02T15:12:15.000Z"
   *        },
   *        {
   *          "id": 3,
   *          "userId": 2,
   *          "evseId": "DE*BER*E0001*01",
   *          "session": "fa8b08d3-0a88-1296-5bce-8e03732f71d8",
   *          "startedAt": "2016-09-05T13:30:35.000Z",
   *          "stoppedAt": "2016-09-05T13:30:44.000Z"
   *        }
   *      ]
   *
   */
  getUserChargings(req: IApiRequest, res: express.Response, next: any): void {

    Promise.resolve()
      .then(() => this.userChargingService.getChargings(req.user.id))
      .then(chargings => res.json(chargings))
      .catch(next)
    ;
  }

  /**
   * @api {get} /users/me/chargings/:id Get UserCharging
   * @apiVersion 1.0.1
   * @apiGroup User
   * @apiDescription Returns charging specified by id.
   *
   * @apiParam {Number} id  id of user charging entity.
   *
   * @apiSuccessExample Success-Response:
   *      HTTP/1.1 200 OK
   *        {
   *          "id": 1,
   *          "userId": 2,
   *          "evseId": "DE*BER*E0001*01",
   *          "session": "eb6c99ff-0a88-1296-730f-e7bfe6f53662",
   *          "startedAt": "2016-09-02T15:03:03.000Z",
   *          "stoppedAt": "2016-09-02T15:05:03.000Z"
   *        }
   */
  /**
   * @api {get} /users/me/chargings/active Get active UserCharging
   * @apiVersion 1.0.1
   * @apiGroup User
   * @apiDescription Returns last active user charging
   *
   * @apiSuccessExample Success-Response:
   *      HTTP/1.1 200 OK
   *        {
   *          "id": 1,
   *          "userId": 2,
   *          "evseId": "DE*BER*E0001*01",
   *          "session": "eb6c99ff-0a88-1296-730f-e7bfe6f53662",
   *          "startedAt": "2016-09-02T15:03:03.000Z",
   *          "stoppedAt": "2016-09-02T15:05:03.000Z"
   *        }
   *
   */
  getUserCharging(req: express.Request, res: express.Response, next: any): void {

    Promise.resolve()
      .then(() => {

        if (req.params.id === 'active') {

          return this.userChargingService.getActiveCharging(req.user.id);
        }

        return this.userChargingService.getCharging(req.params.id, req.user.id);
      })
      .then(charging => res.json(charging))
      .catch(next)
    ;
  }

  /**
   * @api {put} /users/me/chargings Update UserCharging
   * @apiVersion 1.0.1
   * @apiGroup User
   * @apiDescription Updates user charging entity. Currently only the stoppedAt can be updated.
   *
   *
   * @apiSuccessExample Success-Response:
   *      HTTP/1.1 200 OK
   *
   */
  updateUserCharging(req: express.Request, res: express.Response, next: any): void {

    const data = req.body;

    Promise.resolve()
      .then(() => this.userChargingService.updateCharging(req.params.id, req.user.id, data))
      .then(chargings => res.sendStatus(HttpStatus.OK))
      .catch(next)
    ;
  }


// Logs
// -------------------------------

  /**
   * @api {post} /log Create Log
   * @apiVersion 1.0.1
   * @apiGroup Log
   * @apiDescription Creates a log entity.
   *
   * @apiParam {String} appUrl  url of current app state during error occurance.
   * @apiParam {String} message  error message.
   *
   * @apiParam {Number} [userId]  id of user.
   * @apiParam {String} [appVersion]  version of app.
   * @apiParam {String} [cause]  reason of failure.
   *
   * @apiSuccessExample Success-Response:
   *      HTTP/1.1 200 OK
   *
   */
  createLog(req: express.Request, res: express.Response, next: any): void {

    const data = req.body;

    Promise.resolve()
      .then(() => this.checkRequiredParameters(data, ['appUrl', 'message']))
      .then(() => this.logService.log(data.userId, data.appVersion, data.appUrl, data.message, data.cause))
      .then(() => res.sendStatus(HttpStatus.OK))
      .catch(next)
    ;
  }

  // EVSEs
  // -------------------------------

  /**
   * @api {get} /evses?searchTerm={String}&limit={Number} Get EVSEs by search term
   * @apiVersion 1.0.1
   * @apiGroup EVSE
   * @apiDescription Returns evse entities by search term. Looks up evseId property.
   *
   * @apiParam {String} searchTerm  search term for possible evse ids.
   * @apiParam {Number} limit  limiting results.
   * @apiParam {String[]} [attributes]  included attributes of evse entity.
   *
   *
   * @apiSuccessExample Success-Response:
   *      HTTP/1.1 200 OK
   *
   *      [
   *        {
   *          "status": {
   *            "id": 4,
   *            "option": "OutOfService"
   *          },
   *          "chargingLocationId": 488,
   *          "operatorId": "NL*LMS",
   *          "plugs": [
   *            {
   *              "id": 11,
   *              "option": "Type 2 Outlet",
   *              "category": "Type2",
   *              "label": null
   *            }
   *          ],
   *          "chargingFacilities": [
   *            {
   *              "id": 8,
   *              "option": "380 - 480V, 3-Phase ≤ 16A",
   *              "power": "11.1"
   *            }
   *          ],
   *          "operator": {
   *            "name": "Last Mile Solutions",
   *            "hasInterchargeDirect": false,
   *            "id": "NL*LMS",
   *            "parentId": null,
   *            "parent": null
   *          },
   *          "chargingLocation": {
   *            "id": 488,
   *            "longitude": 5.142892,
   *            "latitude": 51.611128
   *          }
   *        },
   *        ...
   *      ]
   *
   */
  /**
   * @api {get} /evses?latitude={Number}&longitude={Number}&limit={Number} Get EVSEs by coordinates
   * @apiVersion 1.0.1
   * @apiGroup EVSE
   * @apiDescription Returns nearest evses entities specified by coordinate.
   *
   * @apiParam {Number} latitude  latitude of reference coordinate.
   * @apiParam {Number} longitude  longitude of reference coordinate.
   * @apiParam {Number} limit  limiting results.
   * @apiParam {String[]} [attributes]  included attributes of evse entity.
   *
   *
   * @apiSuccessExample Success-Response:
   *      HTTP/1.1 200 OK
   *
   *      [
   *        {
   *          "status": {
   *            "id": 4,
   *            "option": "OutOfService"
   *          },
   *          "chargingLocationId": 488,
   *          "operatorId": "NL*LMS",
   *          "plugs": [
   *            {
   *              "id": 11,
   *              "option": "Type 2 Outlet",
   *              "category": "Type2",
   *              "label": null
   *            }
   *          ],
   *          "chargingFacilities": [
   *            {
   *              "id": 8,
   *              "option": "380 - 480V, 3-Phase ≤ 16A",
   *              "power": "11.1"
   *            }
   *          ],
   *          "operator": {
   *            "name": "Last Mile Solutions",
   *            "hasInterchargeDirect": false,
   *            "id": "NL*LMS",
   *            "parentId": null,
   *            "parent": null
   *          },
   *          "chargingLocation": {
   *            "id": 488,
   *            "longitude": 5.142892,
   *            "latitude": 51.611128
   *          }
   *        },
   *        ...
   *      ]
   *
   */
  getEVSEs(req: express.Request, res: express.Response, next: any): void {

    Promise.resolve()
      .then(() => this.checkRequiredParameters(req.query, ['searchTerm', 'limit'], ['latitude', 'longitude', 'limit']))
      .then(() => {

        if ('latitude' in req.query) {

          return this.evseService.getNearestEVSEsByPosition(
            this.utilityService.toFloat(req.query['latitude']),
            this.utilityService.toFloat(req.query['longitude']),
            this.utilityService.toInt(req.query['limit']),
            this.utilityService.toArray<string>(req.query['attributes'])
          );
        }

        if ('searchTerm' in req.query) {

          return this.evseService.getEVSEBySearchTerm(
            req.query['searchTerm'],
            this.utilityService.toInt(req.query['limit']),
            this.utilityService.toArray<string>(req.query['attributes'])
          )
        }
      })
      .then(evses => res.json(evses))
      .catch(next);
  }

  /**
   * @api {get} /evses/:id Get EVSE
   * @apiVersion 1.0.1
   * @apiGroup EVSE
   * @apiDescription Returns evse entity by id.
   *
   * @apiParam {String[]} [attributes]  included attributes of evse entity.
   *
   *
   * @apiSuccessExample Success-Response:
   *      HTTP/1.1 200 OK
   *
   *        {
   *          "status": {
   *            "id": 4,
   *            "option": "OutOfService"
   *          },
   *          "chargingLocationId": 488,
   *          "operatorId": "NL*LMS",
   *          "plugs": [
   *            {
   *              "id": 11,
   *              "option": "Type 2 Outlet",
   *              "category": "Type2",
   *              "label": null
   *            }
   *          ],
   *          "chargingFacilities": [
   *            {
   *              "id": 8,
   *              "option": "380 - 480V, 3-Phase ≤ 16A",
   *              "power": "11.1"
   *            }
   *          ],
   *          "operator": {
   *            "name": "Last Mile Solutions",
   *            "hasInterchargeDirect": false,
   *            "id": "NL*LMS",
   *            "parentId": null,
   *            "parent": null
   *          },
   *          "chargingLocation": {
   *            "id": 488,
   *            "longitude": 5.142892,
   *            "latitude": 51.611128
   *          }
   *        }
   *
   */
  getEVSE(req: express.Request, res: express.Response, next: any): void {

    this.evseService.getEVSEById(req.params['id'], req.query['attributes'])
      .then(evse => res.json(evse))
      .catch(next);
  }

  // Providers
  // -------------------------------

  /**
   * @api {get} /providers/:id/branding Get provider branding
   * @apiVersion 1.0.1
   * @apiGroup Provider
   * @apiDescription Returns branding specified by provider id.
   *
   * @apiParam {String[]} [attributes]  included attributes of branding entity.
   *
   *
   * @apiSuccessExample Success-Response:
   *      HTTP/1.1 200 OK
   *
   *        {
   *         "id": 3,
   *         "logoIcon": "data:image/png;base64,iVBO...wFqcb6LWClIiQAAAABJRU5ErkJggg==",
   *         "markerIcon": "data:image/png;base64,iVBORw0KG...APRiRf0qkCEIAAAAAElFTkSuQmCC",
   *         "timestamp": "2016-09-19T13:26:35.000Z",
   *         "imprint": "<p> ... </p>",
   *         "primaryColor": "#007ea4"
   *        }
   *
   */
  getProviderBranding(req: express.Request, res: express.Response, next: any): void {

    this.providerService.getBranding(req.params['id'], req.query['attributes'])
      .then(branding => res.json(branding))
      .catch(next)
    ;
  }

  // ChargingLocations
  // -------------------------------

  /**
   * @api {get} /charging-locations/:id/evses Get ChargingLocationEVSEs
   * @apiVersion 1.0.1
   * @apiGroup ChargingLocation
   * @apiDescription Returns eves specified by charging location id.
   *
   * @apiParam {String[]} [attributes]  included attributes of evse entity.
   *
   *
   * @apiSuccessExample Success-Response:
   *      HTTP/1.1 200 OK
   *
   *      [
   *        {
   *         "id": "DE*EBW*E3148*2",
   *         "chargingLocationId": 44,
   *         "operatorId": "DE*EBW",
   *         "plugs": [
   *           {
   *             "id": 7,
   *             "option": "Type F Schuko",
   *             "category": "Other",
   *             "label": null
   *           },
   *           {
   *             "id": 11,
   *             "option": "Type 2 Outlet",
   *             "category": "Type2",
   *             "label": null
   *           }
   *         ],
   *         "chargingFacilities": [],
   *         "operator": {
   *           "name": "EnBW",
   *           "hasInterchargeDirect": false,
   *           "id": "DE*EBW",
   *           "parentId": null,
   *           "parent": null
   *         }
   *        },
   *        ...
   *      ]
   *
   */
  getChargingLocationEVSEs(req: express.Request, res: express.Response, next: any): void {

    this.evseService.getEVSEsByChargingLocation(req.params['id'], req.query['attributes'])
      .then(evse => res.json(evse))
      .catch(next);
  }

  /**
   * @api {get} /charging-locations/:id Get ChargingLocation
   * @apiVersion 1.0.1
   * @apiGroup ChargingLocation
   * @apiDescription Returns charging location specified by id.
   *
   *
   * @apiSuccessExample Success-Response:
   *      HTTP/1.1 200 OK
   *
   *      {
   *        "id": 44,
   *        "longitude": 9.234918,
   *        "latitude": 48.818242,
   *        "evses": [
   *          {
   *            "id": "DE*EBW*E3148*2",
   *            "plugs": [
   *              {
   *                "id": 7,
   *                "option": "Type F Schuko",
   *                "category": "Other",
   *                "label": null
   *              },
   *              {
   *                "id": 11,
   *                "option": "Type 2 Outlet",
   *                "category": "Type2",
   *                "label": null
   *              }
   *            ],
   *            "chargingFacilities": []
   *          }
   *        ]
   *      }
   *
   */
  getChargingLocation(req: express.Request, res: express.Response, next: any): void {

    this.chargingLocationService.getChargingLocationById(req.params['id'])
      .then(chargingLocation => res.json(chargingLocation))
      .catch(next);
  }

  /**
   * @api {get} /charging-locations Get ChargingLocations
   * @apiVersion 1.0.1
   * @apiGroup ChargingLocation
   * @apiDescription Returns charging location or location clusters specified by 2 coordinates.
   *                 It depends on the zoom level if the charging locations get clustered or not
   *
   * TODO Probably recap this endpoint, because it currently returns data with different datatypes
   *
   *
   * @apiSuccessExample Success-Response:
   *      HTTP/1.1 200 OK
   *
   *      [
   *      {
   *          "evses": [
   *              {
   *                  "status": {
   *                      "option": "Available"
   *                  },
   *                  "id": "FI*001*E1084"
   *              }
   *          ],
   *          "latitude": 58.376782,
   *          "longitude": 26.741,
   *          "id": 1
   *      },
   *      {
   *          "evses": [
   *              {
   *                  "status": {
   *                      "option": "Occupied"
   *                  },
   *                  "id": "DE*EGO*E001"
   *              }
   *          ],
   *          "latitude": 19.123455,
   *          "longitude": 11.1,
   *          "id": 2
   *      },
   *      {
   *          "latitude": 50.235191,
   *          "longitude": 7.41566,
   *          "groupCount": 1608
   *      },
   *      ...
   *      ]
   *
   */
  getChargingLocations(req: express.Request, res: express.Response, next: any): void {

    Promise.resolve()
      .then(() => this.checkRequiredParameters(req.query, ['longitude1', 'latitude1', 'longitude2', 'latitude2', 'zoom']))
      .then(() => {

        // TODO  This is an ugly fix, which adjusts the specified coordinates by the intercharge-app
        // TODO  if zoom is larger than 12
        // TODO  This has to be adjusted in the app instead of the backend in the next version

        // TODO  Additionally: The zoom value shouldn't be used as well; So there shouldn't be a
        // TODO  mapping from zoom value to epsilon. The epsilon value should be provided instead

        let longitude1 = parseFloat(req.query['longitude1']);
        let latitude1 = parseFloat(req.query['latitude1']);
        let longitude2 = parseFloat(req.query['longitude2']);
        let latitude2 = parseFloat(req.query['latitude2']);
        let zoom = parseInt(req.query['zoom']);

        if (zoom > 11) {

          const WRONG_APP_ADJUSTMENT_VALUE = 0.08;
          const newAdjustmentValue = this.getAdjustValueForCoordinates(zoom);

          longitude1 = longitude1 + WRONG_APP_ADJUSTMENT_VALUE - newAdjustmentValue;
          latitude1 = latitude1 + WRONG_APP_ADJUSTMENT_VALUE - newAdjustmentValue;
          longitude2 = longitude2 - WRONG_APP_ADJUSTMENT_VALUE + newAdjustmentValue;
          latitude2 = latitude2 - WRONG_APP_ADJUSTMENT_VALUE + newAdjustmentValue;
        }

        return this.chargingLocationService.getChargingLocationsByCoordinates(
          longitude1,
          latitude1,
          longitude2,
          latitude2,
          zoom,
          this.utilityService.toBoolean(req.query['isOpen24Hours']),
          this.utilityService.toArray<number>(req.query['chargingFacilityIds']),
          this.utilityService.toArray<number>(req.query['plugIds'])
        )
      })
      .then(chargingLocations => res.json(chargingLocations))
      .catch(next)
    ;
  }

  // Plugs
  // -------------------------------

  /**
   * @api {get} /plugs Get Plugs
   * @apiVersion 1.0.1
   * @apiGroup Plug
   * @apiDescription Returns all available plug types.
   *
   *
   * @apiSuccessExample Success-Response:
   *      HTTP/1.1 200 OK
   *
   *      [
   *      ...
   *      {
   *        "id": 9,
   *        "option": "Type J Swiss Standard",
   *        "category": "Other",
   *        "label": null,
   *        "chargingFacilities": [
   *          {
   *            "id": 0,
   *            "option": "",
   *            "power": null
   *          }
   *        ]
   *      },
   *      {
   *        "id": 10,
   *        "option": "Type 1 Connector (Cable Attached)",
   *        "category": "Type1",
   *        "label": "Type 1",
   *        "chargingFacilities": [
   *          {
   *            "id": 1,
   *            "option": "100 - 120V, 1-Phase ≤ 10A",
   *            "power": "1.2"
   *          },
   *          ...
   *        ]
   *      },
   *      {
   *        "id": 11,
   *        "option": "Type 2 Outlet",
   *        "category": "Type2",
   *        "label": null,
   *        "chargingFacilities": [
   *          {
   *            "id": 3,
   *            "option": "100 - 120V, 1-Phase ≤ 32A",
   *            "power": "3.8"
   *          },
   *          ...
   *        ]
   *      },
   *      ...
   *      ]
   *
   */
  getPlugs(req: express.Request, res: express.Response, next: any): void {

    this.plugService.getPlugs()
      .then(plugs => res.json(plugs))
      .catch(next);
  }

  // ChargingFacilitites
  // -------------------------------

  /**
   * @api {get} /charging-facilities Get ChargingFacilities
   * @apiVersion 1.0.1
   * @apiGroup ChargingFacility
   * @apiDescription Returns all available charging facilities.
   *
   *
   * @apiSuccessExample Success-Response:
   *      HTTP/1.1 200 OK
   *
   *      [
   *        {
   *          "id": 1,
   *          "option": "100 - 120V, 1-Phase ≤ 10A",
   *          "power": "1.2"
   *        },
   *        {
   *          "id": 2,
   *          "option": "100 - 120V, 1-Phase ≤ 16A",
   *          "power": "1.9"
   *        },
   *        {
   *          "id": 3,
   *          "option": "100 - 120V, 1-Phase ≤ 32A",
   *          "power": "3.8"
   *        },
   *        {
   *          "id": 4,
   *          "option": "200 - 240V, 1-Phase ≤ 10A",
   *          "power": "2.3"
   *        },
   *        ...
   *      ]
   *
   */
  getChargingFacilities(req: express.Request, res: express.Response, next: any): void {

    this.chargingFaciliyService.getChargingFacilities()
      .then(chargingFacilities => res.json(chargingFacilities))
      .catch(next);
  }


// Middleware implementations
// ===============================

  checkAuthentication(req: IApiRequest, res: express.Response, next: any): void {

    let rawToken = req.headers[config.request.accessTokenHeader];
    let match = config.request.authTokenRegex.exec(rawToken);
    let token;

    if (match && match.length > 1) {

      token = match[1];
    }

    if (!token) {

      res.sendStatus(HttpStatus.Unauthorized);
      return;
    }

    this.userService.checkAuthentication(token)
      .then((user) => {

        req.user = user;
        next();
      })
      .catch(next)
  }

  processErrors(err: any, req: express.Request, res: express.Response, next: any): any {

    // log errors
    // ------------------
    logger.error(err);

    // http response
    // ------------------

    // Security header for content sniffing
    res.setHeader('X-Content-Type-Options', 'nosniff');

    err = err || {message: 'unknown'};
    const status = err.statusCode || HttpStatus.InternalServerError;
    const secureToShow = err.secureToShow;

    delete err.secureToShow;
    delete err.statusCode;

    if (secureToShow) {

      res
        .status(status)
        .json(err)
      ;
    } else {

      if (config.environment === 'development') {

        res
          .status(status)
          .send(err && err.toString ? err.toString() : '')
        ;
      } else {

        res.sendStatus(status);
      }
    }
  }

  // WebSocket namespaces
  // ===============================

  @SocketNamespace
  evseStates: Namespace;


  // Helper
  // ===============================

  /**
   * TODO to fix an issue for front end, see getChargingLocations
   */
  private getAdjustValueForCoordinates(zoom: number) {

    if (zoom > 15) {
      return 0.005;
    }

    switch (zoom) {
      case 15:
        return 0.01;
      case 14:
        return 0.015;
      case 13:
        return 0.02;
      case 12:
        return 0.07;
      default:
        return 0;
    }
  }
}
