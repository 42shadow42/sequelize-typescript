///<reference path="../typings/socket.io/socket.io.d.ts"/>

import express = require('express');
import Promise = require('bluebird');
import fs = require('fs');
import soap = require('soap');
import {Inject} from "di-ts";
import Namespace = SocketIO.Namespace;
import {SocketNamespace} from "../websockets/SocketNamespace";
import {ApiAbstract} from "./ApiAbstract";
import {CronService} from "../services/CronService";
import {EVSEService} from "../services/EVSEService";
import {UserService} from "../services/UserService";
import {ParametersMissingError} from "../errors/ParametersMissingError";
import {BadRequestError} from "../errors/BadRequestError";
import {config} from "../config";
import {IApiRequest} from "../interfaces/IApiRequest";
import {ChargingLocationService} from "../services/ChargingLocationService";
import {LogService} from "../services/LogService";
import {ProviderService} from "../services/ProviderService";
import {UserChargingService} from "../services/UserChargingService";
import {UtilityService} from "../services/UtilityService";
import {PlugService} from "../services/PlugService";
const request = require('request');

@Inject
export class ApiV1 extends ApiAbstract {

  constructor(protected utilityService: UtilityService,
              protected cronService: CronService,
              protected evseService: EVSEService,
              protected providerService: ProviderService,
              protected plugService: PlugService,
              protected chargingLocationService: ChargingLocationService,
              protected logService: LogService,
              protected userChargingService: UserChargingService,
              protected userService: UserService) {

    super();

    this.cronService.scheduleEvseDataImport();
    this.cronService.scheduleEvseStatusImport();

    this.evseService.initEVSEStates(this.evseStates);
  }

  // REST implementations
  // ===============================


  getOutComingIp(req: express.Request, res: express.Response, next: any): void {

    request('http://icanhazip.com/', (error, response, body) => {
      if (!error && response.statusCode == 200) {

        res.send(body);
        return;
      }

      res.send(error);
    })
  }

// User
  // -------------------------------

  /**
   * @api {post} /users
   * @apiVersion 1.0.0
   * @apiName Create user
   * @apiGroup User
   * @apiDescription Creates an auto generated user or a normal one or simply authenticates via HBS
   *
   *
   * @apiParam {String} languageCode Code which specifies the users language.
   *
   * @apiParam {String} [providerId] Id of users provider.
   *
   * @apiParam {String} [evcoId]  evcoId of User.
   * @apiParam {String} [password]  password of User.
   *
   * @apiSuccessExample Success-Response:
   *      HTTP/1.1 200 OK
   *      {
   *        "registrationDate": "2016-08-23T07:12:28.000Z",
   *        "id": 4,
   *        "code": "f32c6bf0-6900-11e6-971e-7130308399f5",
   *        "isAutoGenerated": true,
   *        "languageCode": "de-DE",
   *        "token": "eyJ0eXAiOiJKV1....--e4huE"
   *      }
   *
   */
  createUser(req: express.Request, res: express.Response, next: any): void {

    const data = req.body;

    Promise.resolve()
      .then(() => {

        if (!data.languageCode) {

          throw new ParametersMissingError(['languageCode']);
        }
      })
      .then(() => this.userService.registerOrAuthenticate(
        data.languageCode, data.providerId, data.evcoId, data.password))
      .then((user) => res.json(user))
      .catch(next)
    ;
  }

  /**
   * @api {put} /users/me
   * @apiVersion 1.0.0
   * @apiName update User
   * @apiGroup User
   * @apiDescription Updates the current authenticated user
   *
   *
   *
   * @apiSuccessExample Success-Response:
   *      HTTP/1.1 200 OK
   *
   */
  updateUser(req: IApiRequest, res: express.Response, next: any): void {

    const data = req.body;

    if ('newPassword' in data) {

      this.userService.updatePassword(req.user, data['newPassword'])
        .then(() => res.sendStatus(HttpStatus.OK))
        .catch(next);
    } else {

      this.userService.update(req.user, data)
        .then(() => res.sendStatus(HttpStatus.OK))
        .catch(next);
    }
  }

  loginFromAutoGenerated(req: IApiRequest, res: express.Response, next: any): void {

    const data = req.body;

    Promise.resolve()
      .then(() => this.checkRequiredParameters(data, ['evcoId', 'password']))
      .then(() => this.userService.loginFromAutoGenerated(req.user.code, data.evcoId, data.password))
      .then((user) => res.json(user))
      .catch(next)
    ;
  }

  authUser(req: express.Request, res: express.Response, next: any): void {

    const data = req.body;

    Promise.resolve()
      .then(() => {

        if (!data.code && !data.evcoId && !data.password) {

          throw new BadRequestError('Both evcoId and password should be provided ' +
            'or code')
        }
      })
      .then(() => this.userService.getFullUser(data.evcoId || data.code))
      .then(user => this.userService.authenticate(user, data.password))
      .then((user) => res.json(user))
      .catch(next)
    ;
  }

  createUserCharging(req: IApiRequest, res: express.Response, next: any): void {

    const data = req.body;

    Promise.resolve()
      .then(() => this.checkRequiredParameters(data, ['evseId', 'session', 'startedAt']))
      .then(() => this.userChargingService.createCharging(req.user.id, data.evseId, data.session, data.startedAt))
      .then(charging => res.json(charging))
      .catch(next)
    ;
  }

  getUserChargings(req: IApiRequest, res: express.Response, next: any): void {

    Promise.resolve()
      .then(() => this.userChargingService.getChargings(req.user.id))
      .then(chargings => res.json(chargings))
      .catch(next)
    ;
  }

  getUserCharging(req: express.Request, res: express.Response, next: any): void {

    Promise.resolve()
      .then(() => {

        if (req.params.id === 'active') {

          return this.userChargingService.getActiveCharging(req.user.id);
        }

        return this.userChargingService.getCharging(req.params.id, req.user.id);
      })
      .then(charging => res.json(charging))
      .catch(next)
    ;
  }

  updateUserCharging(req: express.Request, res: express.Response, next: any): void {

    const data = req.body;

    Promise.resolve()
      .then(() => this.userChargingService.updateCharging(req.params.id, req.user.id, data))
      .then(chargings => res.sendStatus(HttpStatus.OK))
      .catch(next)
    ;
  }


// Logs
// -------------------------------

  createLog(req: express.Request, res: express.Response, next: any): void {

    const data = req.body;

    Promise.resolve()
      .then(() => this.checkRequiredParameters(data, ['appUrl', 'message']))
      .then(() => this.logService.log(data.userId, data.appVersion, data.appUrl, data.message, data.cause))
      .then(() => res.sendStatus(HttpStatus.OK))
      .catch(next)
    ;
  }

  // EVSEs
  // -------------------------------

  getEVSEs(req: express.Request, res: express.Response, next: any): void {

    Promise.resolve()
      .then(() => this.checkRequiredParameters(req.query, ['searchTerm']))
      .then(() => this.evseService.getEVSEBySearchTerm(req.query['searchTerm'], req.query['attributes']))
      .then(evses => res.json(evses))
      .catch(next);
  }

  getEVSE(req: express.Request, res: express.Response, next: any): void {

    this.evseService.getEVSEById(req.params['id'], req.query['attributes'])
      .then(evse => res.json(evse))
      .catch(next);
  }

  // Providers
  // -------------------------------

  getProviderBranding(req: express.Request, res: express.Response, next: any): void {

    this.providerService.getBranding(req.params['id'], req.query['attributes'])
      .then(branding => res.json(branding))
      .catch(next)
    ;
  }

  // ChargingLocations
  // -------------------------------

  getChargingLocationEVSEs(req: express.Request, res: express.Response, next: any): void {

    this.evseService.getEVSEsByChargingLocation(req.params['id'], req.query['attributes'])
      .then(evse => res.json(evse))
      .catch(next);
  }

  getChargingLocation(req: express.Request, res: express.Response, next: any): void {

    this.chargingLocationService.getChargingLocationById(req.params['id'])
      .then(chargingLocation => res.json(chargingLocation))
      .catch(next);
  }

  getChargingLocations(req: express.Request, res: express.Response, next: any): void {

    Promise.resolve()
      .then(() => this.checkRequiredParameters(req.query, ['longitude1', 'latitude1', 'longitude2', 'latitude2', 'zoom']))
      .then(() => this.chargingLocationService.getChargingLocationsByCoordinates(
        parseFloat(req.query['longitude1']),
        parseFloat(req.query['latitude1']),
        parseFloat(req.query['longitude2']),
        parseFloat(req.query['latitude2']),
        parseInt(req.query['zoom']),
        this.utilityService.toBoolean(req.query['isOpen24Hours']),
        this.utilityService.toArray<number>(req.query['chargingFacilityIds']),
        this.utilityService.toArray<number>(req.query['plugIds'])
      ))
      .then(chargingLocations => res.json(chargingLocations))
      .catch(next)
    ;
  }

  // Plugs
  // -------------------------------

  getPlugs(req: express.Request, res: express.Response, next: any): void {

    this.plugService.getPlugs()
      .then(evse => res.json(evse))
      .catch(next);
  }


// Middleware implementations
// ===============================

  checkAuthentication(req: IApiRequest, res: express.Response, next: any): void {

    let rawToken = req.headers[config.request.accessTokenHeader];
    let match = config.request.authTokenRegex.exec(rawToken);
    let token;

    if (match && match.length > 1) {

      token = match[1];
    }

    if (!token) {

      res.sendStatus(HttpStatus.Unauthorized);
      return;
    }

    this.userService.checkAuthentication(token)
      .then((user) => {

        req.user = user;
        next();
      })
      .catch(next)
  }

// WebSocket namespaces
// ===============================

  @SocketNamespace
  evseStates: Namespace;

}
