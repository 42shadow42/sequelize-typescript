/* tslint:disable:max-classes-per-file */

import {expect, use} from 'chai';
import * as chaiAsPromised from 'chai-as-promised';
import * as OriginSequelize from 'sequelize';
import * as Promise from 'bluebird';
import {createSequelize} from "../utils/sequelize";
import {
  Sequelize, Model, Table, Column, BelongsToMany,
  ForeignKey, HasOne, HasMany, BelongsTo, DataType
} from "../../index";
import {expectAutoGeneratedFunctions} from "../utils/association";
import {assertInstance} from "../utils/common";

use(chaiAsPromised);

const Association: any = OriginSequelize['Association'];

describe('association', () => {

  const sequelize: Sequelize = createSequelize(false);

  const jsForDummiesBook = {
    title: 'JS for dummies'
  };

  const crimeAndPunishmentBook = {
    title: 'Crime and Punishment'
  };

  const elisa = {name: 'elisa'};
  const robin = {name: 'robin'};
  const nelly = {name: 'nelly'};
  const brom = {name: 'brom'};

  describe('One-to-many', () => {

    function oneToManyTestSuites(Book: typeof Model, Page: typeof Model): void {

      const sherlockHolmesBook = {
        title: 'Sherlock Holmes',
        pages: [
          {content: 'Watson'},
          {content: 'Moriaty'},
        ]
      };

      const page1 = {
        content: 'written by Oscar Wilde',
        book: {
          title: 'The Picture of Dorian Gray'
        }
      };

      const page2 = {
        content: 'js1'
      };
      const page3 = {
        content: 'js2'
      };
      const page4 = {
        content: 'js3'
      };
      const page5 = {
        content: 'js4'
      };

      beforeEach(() => {
        sequelize.addModels([Page, Book]);

        return sequelize.sync({force: true});
      });

      it('should create models with specified relations', () => {

        expect(Book)
          .to.have.property('associations')
          .that.has.property('pages')
          .that.is.an.instanceOf(Association['HasMany'])
          .and.has.property('foreignKey', 'bookId')
        ;

        expect(Page)
          .to.have.property('associations')
          .that.has.property('book')
          .that.is.an.instanceOf(Association['BelongsTo'])
          .and.has.property('foreignKey', 'bookId')
        ;
      });

      it('should create models with generated functions on its prototype', () => {

        expectAutoGeneratedFunctions(Book, {singular: 'page', plural: 'pages'});
        expectAutoGeneratedFunctions(Page, {singular: 'book'});
      });

      describe('create()', () => {

        it('should create instances and relation between', () =>

          Promise.all([
            Book.create(sherlockHolmesBook, {include: [Page]})
              .then(book => {

                assertInstance(book, sherlockHolmesBook);
              }),
            Page.create(page1, {include: [Book]})
              .then(page => {

                assertInstance(page, page1);
              })
          ])
        );

        it('should create instances without relation', () =>
          Book
            .create({
              title: 'Sherlock Holmes',
              pages: [
                {content: 'Watson'},
                {content: 'Moriaty'},
              ]
            })
            .then(book => {

              expect(book)
                .to.have.property('id')
                .that.is.not.null;

              expect(book)
                .not.to.have.property('pages');
            })
        );
      });

      describe('findById()', () => {

        it('should find instances with related instances', () =>

          Promise.all([
            Book.create(sherlockHolmesBook, {include: [Page]})
              .then(book => Book.findById(book.id, {include: [Page]}))
              .then(book => {

                assertInstance(book, sherlockHolmesBook);
              }),
            Page.create(page1, {include: [Book]})
              .then(page => Page.findById(page.id, {include: [Book]}))
              .then(page => {

                assertInstance(page, page1);
              })
          ])
        );
      });

      describe('findOne()', () => {

        it('should find instances with related instances', () =>

          Promise.all([
            Book.create(sherlockHolmesBook, {include: [Page]})
              .then(book => Book.findOne({include: [Page], where: {id: book.id}}))
              .then(book => {

                assertInstance(book, sherlockHolmesBook);
              }),
            Page.create(page1, {include: [Book]})
              .then(page => Page.findOne({include: [Book], where: {id: page.id}}))
              .then(page => {

                assertInstance(page, page1);
              })
          ])
        );
      });

      describe('findAll()', () => {

        it('should find instances with related instances', () =>

          Promise.all([
            Book.create(sherlockHolmesBook, {include: [Page]})
              .then(book => Book.findAll({include: [Page], where: {id: book.id}}))
              .then(books => {

                assertInstance(books[0], sherlockHolmesBook);
              }),
            Page.create(page1, {include: [Book]})
              .then(page => Page.findAll({include: [Book], where: {id: page.id}}))
              .then(pages => {

                assertInstance(pages[0], page1);
              })
          ])
        );
      });

      describe('$get', () => {

        it('should get related instances of source instance', () =>

          Book.create(sherlockHolmesBook, {include: [Page]})
            .then(book => Book.findById(book.id))
            .then(book =>
              book
                .$get('pages')
                .then(pages => {

                  assertInstance(pages, sherlockHolmesBook.pages);
                })
            )
        );

        it('should get related instance of source instance', () =>

          Page.create(page1, {include: [Book]})
            .then(page => Page.findById(page.id))
            .then(page =>
              page
                .$get('book')
                .then(book => {

                  assertInstance(book, page1.book);
                })
            )
        );
      });

      describe('$set', () => {

        it('should set relation between specified instances and source instance', () =>

          Promise
            .all([
              Book.create(jsForDummiesBook),
              Page.create(page2),
              Page.create(page3)
            ])
            .then(([book, ...pages]) =>
              book
                .$set('pages', pages)
                .then(() => Book.findById(book.id, {include: [Page]}))
                .then(_book => {

                  assertInstance(_book, Object.assign({pages: [page2, page3]}, jsForDummiesBook));
                })
            )
        );

        it('should override previous relations', () =>

          Promise
            .all([
              Book.create(jsForDummiesBook),
              Page.create(page2),
              Page.create(page3),
              Page.create(page4),
              Page.create(page5),
            ])
            .then(([book, pageA, pageB, pageC, pageD]) =>
              book
                .$set('pages', [pageA, pageB])
                .then(() => Book.findById(book.id, {include: [Page]}))
                .then(_book => {

                  assertInstance(_book, Object.assign({pages: [page2, page3]}, jsForDummiesBook));
                })
                // override previous pages
                .then(() => book.$set('pages', [pageC, pageD]))
                .then(() => Book.findById(book.id, {include: [Page]}))
                .then(_book => {

                  // and check, if there are overridden
                  assertInstance(_book, Object.assign({pages: [page4, page5]}, jsForDummiesBook));
                })
            )
        );

        it('should set relation between specified instance and source instance', () =>

          Promise
            .all([
              Page.create(page2),
              Book.create(jsForDummiesBook)
            ])
            .then(([page, book]) =>
              page
                .$set('book', book)
                .then(() => Page.findById(page.id, {include: [Book]}))
                .then(_page => {

                  assertInstance(_page, Object.assign({book: jsForDummiesBook}, page2));
                })
            )
        );

        it('should override previous relation', () =>

          Promise
            .all([
              Page.create(page2),
              Book.create(jsForDummiesBook),
              Book.create(crimeAndPunishmentBook),
            ])
            .then(([page, bookA, bookB]) =>
              page
                .$set('book', bookA)
                .then(() => Page.findById(page.id, {include: [Book]}))
                .then(_page => {

                  assertInstance(_page, Object.assign({book: jsForDummiesBook}, page2));
                })
                .then(() => page.$set('book', bookB))
                .then(() => Page.findById(page.id, {include: [Book]}))
                .then(_page => {

                  assertInstance(_page, Object.assign({book: crimeAndPunishmentBook}, page2));
                })
            )
        );
      });

      describe('$add', () => {

        it('should add relation between specified instance and source instance', () =>

          Promise
            .all([
              Book.create(jsForDummiesBook),
              Page.create(page2),
            ])
            .then(([book, page]) =>
              book
                .$add('page', page)
                .then(() => Book.findById(book.id, {include: [Page]}))
                .then(_book => {

                  assertInstance(_book, Object.assign({pages: [page2]}, jsForDummiesBook));
                })
            )
        );

        it('should add relations between specified instance and source instance', () =>

          Promise
            .all([
              Book.create(jsForDummiesBook),
              Page.create(page2),
              Page.create(page3),
            ])
            .then(([book, ...pages]) =>
              book
                .$add('pages', pages)
                .then(() => Book.findById(book.id, {include: [Page]}))
                .then(_book => {

                  assertInstance(_book, Object.assign({pages: [page2, page3]}, jsForDummiesBook));
                })
            )
        );

        it('should not override previous relations', () =>

          Promise
            .all([
              Book.create(jsForDummiesBook),
              Page.create(page2),
              Page.create(page3),
            ])
            .then(([book, pageA, pageB]) =>
              book
                .$add('page', pageA)
                .then(() => Book.findById(book.id, {include: [Page]}))
                .then(_book => {

                  assertInstance(_book, Object.assign({pages: [page2]}, jsForDummiesBook));
                })
                // now we add another page
                .then(() => book.$add('page', pageB))
                .then(() => Book.findById(book.id, {include: [Page]}))
                .then(_book => {

                  // ... and check, if both pages exist
                  assertInstance(_book, Object.assign({pages: [page2, page3]}, jsForDummiesBook));
                })
            )
        );
      });

      describe('$create', () => {

        it('should create new instance and add relation between new instance and source instance (has many)', () =>

          Book.create(jsForDummiesBook)
            .then((book) =>
              book
                .$create('page', page2)
                .then(page => {

                  assertInstance(page, page2);
                })
                .then(() => Book.findById(book.id, {include: [Page]}))
                .then(_book => {

                  assertInstance(_book, Object.assign({pages: [page2]}, jsForDummiesBook));
                })
            )
        );

        it('should create new instance and add relation between new instance and source instance (belongs to)', () =>

          Page.create(page3)
            .then((page) =>
              page
                .$create('book', jsForDummiesBook)
                .then(() => Page.findById(page.id, {include: [Book]}))
                .then(_page => {

                  assertInstance(_page, Object.assign({book: jsForDummiesBook}, page3));
                })
            )
        );

      });

      describe('$has', () => {

        it('should return true due to relation between specified instances and source instance', () =>

          Book.create<any>(sherlockHolmesBook, {include: [Page]})
            .then((book) =>
              Book
                .findById(book.id)
                .then(_book => _book.$has('pages', book.pages))
                .then(result => {

                  expect(result).to.be.true;
                })
            )
        );

        it('should return false due to no relation between specified instance and source instance', () =>

          Promise
            .all([
              Book.create<any>(sherlockHolmesBook, {include: [Page]}),
              Page.create(page3)
            ])
            .then(([book, page]) =>
              Book
                .findById(book.id)
                .then(_book => _book.$has('pages', page))
                .then(result => {

                  expect(result).to.be.false;
                })
            )
        );

      });

      describe('$count', () => {

        it('should return number of specified relations', () =>

          Book.create<any>(sherlockHolmesBook, {include: [Page]})
            .then((book) =>
              Book
                .findById(book.id)
                .then(_book => _book.$count('pages'))
                .then(result => {

                  expect(result).to.equal(sherlockHolmesBook.pages.length);
                })
            )
        );

        it('should return 0, since source instance has no relations', () =>

          Book.create(sherlockHolmesBook)
            .then((book) =>
              Book
                .findById(book.id)
                .then(_book => _book.$count('pages'))
                .then(result => {

                  expect(result).to.equal(0);
                })
            )
        );


      });

      describe('$remove', () => {

        it('should remove relation between specified instance and source instance', () =>

          Book.create<any>(sherlockHolmesBook, {include: [Page]})
            .then((book) =>
              Book
                .findById<any>(book.id, {include: [Page]})
                .then(_book => {

                  assertInstance(_book, sherlockHolmesBook);

                  return _book.$remove('page', _book.pages[0]);
                })
                .then(() => Book.findById<any>(book.id, {include: [Page]}))
                .then(_book => {

                  assertInstance(_book, {
                    title: sherlockHolmesBook.title,
                    pages: [sherlockHolmesBook.pages[1]]
                  });
                })
            )
        );

        it('should remove relations between specified instances and source instance', () =>

          Book.create<any>(sherlockHolmesBook, {include: [Page]})
            .then((book) =>
              Book
                .findById<any>(book.id, {include: [Page]})
                .then(_book => {

                  assertInstance(_book, sherlockHolmesBook);

                  return _book.$remove('pages', _book.pages);
                })
                .then(() => Book.findById<any>(book.id, {include: [Page]}))
                .then(_book => {

                  assertInstance(_book, {
                    title: sherlockHolmesBook.title
                  });
                })
            )
        );
      });
    }

    describe('resolve foreign keys automatically', () => {

      @Table
      class Book extends Model<Book> {

        @Column
        title: string;

        @HasMany(() => Page)
        pages: Page[];
      }

      @Table
      class Page extends Model<Page> {

        @Column(DataType.TEXT)
        content: string;

        @ForeignKey(() => Book)
        bookId: number;

        @BelongsTo(() => Book)
        book: Book;
      }

      oneToManyTestSuites(Book, Page);
    });

    describe('set foreign keys explicitly', () => {

      @Table
      class Book2 extends Model<Book2> {

        @Column
        title: string;

        @HasMany(() => Page2, 'bookId')
        pages: Page2[];
      }

      @Table
      class Page2 extends Model<Page2> {

        @Column(DataType.TEXT)
        content: string;

        @BelongsTo(() => Book2, 'bookId')
        book: Book2;
      }

      oneToManyTestSuites(Book2, Page2);
    });
  });

  describe('Many-to-many', () => {

    function manyToManyTestSuites(Book: typeof Model, Author: typeof Model, AuthorBook?: typeof Model): void {

      const models = [Book, Author];

      if (AuthorBook) {
        models.push(AuthorBook);
      }

      sequelize.addModels(models);

      const sherlockHolmesBook = {
        title: 'Sherlock Holmes',
        authors: [
          {name: 'Sir Arthur Conan Doyle'},
          {name: 'No Ghost'},
        ]
      };
      const julesVerne = {
        name: 'Jules Verne',
        books: [
          {title: 'Journey to the Center of the Earth'},
          {title: 'Twenty Thousand Leagues Under the Sea'},
        ]
      };

      beforeEach(() => sequelize.sync({force: true}));

      it('should create models with specified relations', () => {

        expect(Book)
          .to.have.property('associations')
          .that.has.property('authors')
          .that.is.an.instanceOf(Association['BelongsToMany'])
          .and.has.property('foreignKey', 'bookId')
        ;

        expect(Author)
          .to.have.property('associations')
          .that.has.property('books')
          .that.is.an.instanceOf(Association['BelongsToMany'])
          .and.has.property('foreignKey', 'authorId')
        ;
      });

      it('should create models with generated functions on its prototype', () => {

        expectAutoGeneratedFunctions(Book, {singular: 'author', plural: 'authors'});
        expectAutoGeneratedFunctions(Author, {singular: 'book', plural: 'books'});
      });

      describe('create()', () => {

        it('should create instances and relation between', () =>

          Promise.all([
            Book.create(sherlockHolmesBook, {include: [Author]})
              .then(book => {

                assertInstance(book, sherlockHolmesBook);
              }),
            Author.create(julesVerne, {include: [Book]})
              .then(author => {

                assertInstance(author, julesVerne);
              })
          ])
        );

        it('should create instances without relation', () =>
          Author.create(julesVerne)
            .then(author => {

              assertInstance(author, {name: julesVerne.name});
            })
        );
      });

      describe('findById()', () => {

        it('should find instances with related instances', () =>

          Promise.all([
            Book.create(sherlockHolmesBook, {include: [Author]})
              .then(book => Book.findById(book.id, {include: [Author]}))
              .then(book => {

                assertInstance(book, sherlockHolmesBook);
              }),
            Author.create(julesVerne, {include: [Book]})
              .then(author => Author.findById(author.id, {include: [Book]}))
              .then(author => {

                assertInstance(author, julesVerne);
              })
          ])
        );
      });

      describe('findOne()', () => {

        it('should find instances with related instances', () =>

          Promise.all([
            Book.create(sherlockHolmesBook, {include: [Author]})
              .then(book => Book.findOne({include: [Author], where: {id: book.id}}))
              .then(book => {

                assertInstance(book, sherlockHolmesBook);
              }),
            Author.create(julesVerne, {include: [Book]})
              .then(author => Author.findOne({include: [Book], where: {id: author.id}}))
              .then(author => {

                assertInstance(author, julesVerne);
              })
          ])
        );
      });

      describe('findAll()', () => {

        it('should find instances with related instances', () =>

          Promise.all([
            Book.create(sherlockHolmesBook, {include: [Author]})
              .then(book => Book.findAll({include: [Author], where: {id: book.id}}))
              .then(books => {

                assertInstance(books[0], sherlockHolmesBook);
              }),
            Author.create(julesVerne, {include: [Book]})
              .then(author => Author.findAll({include: [Book], where: {id: author.id}}))
              .then(authors => {

                assertInstance(authors[0], julesVerne);
              })
          ])
        );
      });

      describe('$get', () => {

        it('should get related instances of source instance', () =>

          Promise
            .all([
              Book.create(sherlockHolmesBook, {include: [Author]})
                .then(book => Book.findById(book.id))
                .then(book =>
                  book
                    .$get('authors')
                    .then(authors => {

                      assertInstance(authors, sherlockHolmesBook.authors);
                    })
                ),
              Author.create(julesVerne, {include: [Book]})
                .then(author => Author.findById(author.id))
                .then(author =>
                  author
                    .$get('books')
                    .then(books => {

                      assertInstance(books, julesVerne.books);
                    })
                )

            ])
        );
      });

      describe('$set', () => {

        it('should set relation between specified instances and source instance', () =>

          Promise
            .all([
              Book.create(jsForDummiesBook),
              Author.create(elisa),
              Author.create(robin)
            ])
            .then(([book, ...authors]) =>
              book
                .$set('authors', authors)
                .then(() => Book.findById(book.id, {include: [Author]}))
                .then(_book => {

                  assertInstance(_book, Object.assign({authors: [elisa, robin]}, jsForDummiesBook));
                })
            )
        );

        it('should override previous relations', () =>

          Promise
            .all([
              Book.create(jsForDummiesBook),
              Author.create(elisa),
              Author.create(nelly),
              Author.create(brom),
              Author.create(robin),
            ])
            .then(([book, _elisa, _nelly, _brom, _robin]) =>
              book
                .$set('authors', [_elisa, _nelly])
                .then(() => Book.findById(book.id, {include: [Author]}))
                .then(_book => {

                  assertInstance(_book, Object.assign({authors: [elisa, nelly]}, jsForDummiesBook));
                })
                // override previous authors
                .then(() => book.$set('authors', [_brom, _robin]))
                .then(() => Book.findById(book.id, {include: [Author]}))
                .then(_book => {

                  // and check, if there are overridden
                  assertInstance(_book, Object.assign({authors: [brom, robin]}, jsForDummiesBook));
                })
            )
        );

      });

      describe('$add', () => {

        it('should add relation between specified instance and source instance', () =>

          Promise
            .all([
              Book.create(jsForDummiesBook),
              Author.create(elisa),
            ])
            .then(([book, _elisa]) =>
              book
                .$add('author', _elisa)
                .then(() => Book.findById(book.id, {include: [Author]}))
                .then(_book => {

                  assertInstance(_book, Object.assign({authors: [elisa]}, jsForDummiesBook));
                })
            )
        );

        it('should add relations between specified instance and source instance', () =>

          Promise
            .all([
              Book.create(jsForDummiesBook),
              Author.create(elisa),
              Author.create(brom),
            ])
            .then(([book, ...authors]) =>
              book
                .$add('authors', authors)
                .then(() => Book.findById(book.id, {include: [Author]}))
                .then(_book => {

                  assertInstance(_book, Object.assign({authors: [elisa, brom]}, jsForDummiesBook));
                })
            )
        );

        it('should not override previous relations', () =>

          Promise
            .all([
              Book.create(jsForDummiesBook),
              Author.create(elisa),
              Author.create(brom),
            ])
            .then(([book, _elisa, _brom]) =>
              book
                .$add('author', _elisa)
                .then(() => Book.findById(book.id, {include: [Author]}))
                .then(_book => {

                  assertInstance(_book, Object.assign({authors: [elisa]}, jsForDummiesBook));
                })
                // now we add another author
                .then(() => book.$add('author', _brom))
                .then(() => Book.findById(book.id, {include: [Author]}))
                .then(_book => {

                  // ... and check, if both authors exist
                  assertInstance(_book, Object.assign({authors: [elisa, brom]}, jsForDummiesBook));
                })
            )
        );
      });

      describe('$create', () => {

        it('should create new instance and add relation between new instance and source instance (has many)', () =>

          Book.create(jsForDummiesBook)
            .then((book) =>
              book
                .$create('author', elisa)
                .then(author => {

                  assertInstance(author, elisa);
                })
                .then(() => Book.findById(book.id, {include: [Author]}))
                .then(_book => {

                  assertInstance(_book, Object.assign({authors: [elisa]}, jsForDummiesBook));
                })
            )
        );

        it('should create new instance and add relation between new instance and source instance (belongs to)', () =>

          Author.create(elisa)
            .then((author) =>
              author
                .$create('book', jsForDummiesBook)
                .then(book => {

                  assertInstance(book, jsForDummiesBook);
                })
                .then(() => Author.findById(author.id, {include: [Book]}))
                .then(_author => {

                  assertInstance(_author, Object.assign({books: [jsForDummiesBook]}, elisa));
                })
            )
        );

      });

      describe('$has', () => {

        it('should return true due to relation between specified instances and source instance', () =>

          Book.create<any>(sherlockHolmesBook, {include: [Author]})
            .then((book) =>
              Book
                .findById(book.id)
                .then(_book => _book.$has('authors', book.authors))
                .then(result => {

                  expect(result).to.be.true;
                })
            )
        );

        it('should return false due to no relation between specified instance and source instance', () =>

          Promise
            .all([
              Book.create<any>(sherlockHolmesBook, {include: [Author]}),
              Author.create(elisa)
            ])
            .then(([book, author]) =>
              Book
                .findById(book.id)
                .then(_book => _book.$has('authors', author))
                .then(result => {

                  expect(result).to.be.false;
                })
            )
        );

      });

      describe('$count', () => {

        it('should return number of specified relations', () =>

          Book.create<any>(sherlockHolmesBook, {include: [Author]})
            .then((book) =>
              Book
                .findById(book.id)
                .then(_book => _book.$count('authors'))
                .then(result => {

                  expect(result).to.equal(sherlockHolmesBook.authors.length);
                })
            )
        );

        it('should return 0, since source instance has no relations', () =>

          Author.create(elisa)
            .then((author) =>
              Author
                .findById(author.id)
                .then(_author => _author.$count('books'))
                .then(result => {

                  expect(result).to.equal(0);
                })
            )
        );


      });

      describe('$remove', () => {

        it('should remove relation between specified instance and source instance', () =>

          Book.create<any>(sherlockHolmesBook, {include: [Author]})
            .then((book) =>
              Book
                .findById<any>(book.id, {include: [Author]})
                .then(_book => {

                  assertInstance(_book, sherlockHolmesBook);

                  return _book.$remove('author', _book.authors[0]);
                })
                .then(() => Book.findById<any>(book.id, {include: [Author]}))
                .then(_book => {

                  assertInstance(_book, {
                    title: sherlockHolmesBook.title,
                    authors: [sherlockHolmesBook.authors[1]]
                  });
                })
            )
        );

        it('should remove relations between specified instances and source instance', () =>

          Author.create<any>(julesVerne, {include: [Book]})
            .then((author) =>
              Author
                .findById<any>(author.id, {include: [Book]})
                .then(_author => {

                  assertInstance(_author, julesVerne);

                  return _author.$remove('books', _author.books);
                })
                .then(() => Author.findById<any>(author.id, {include: [Book]}))
                .then(_author => {

                  assertInstance(_author, {
                    name: julesVerne.name
                  });
                })
            )
        );
      });
    }

    describe('resolve foreign keys automatically', () => {

      @Table
      class Book extends Model<Book> {

        @Column
        title: string;

        @BelongsToMany(() => Author, () => AuthorBook)
        authors: Author[];
      }

      @Table
      class AuthorBook extends Model<AuthorBook> {

        @ForeignKey(() => Book)
        bookId: number;

        @ForeignKey(() => Author)
        authorId: number;
      }

      @Table
      class Author extends Model<Author> {

        @Column
        name: string;

        @BelongsToMany(() => Book, () => AuthorBook)
        books: Book;
      }

      manyToManyTestSuites(Book, Author, AuthorBook);
    });

    describe('set foreign keys explicitly', () => {

      @Table
      class Book2 extends Model<Book2> {

        @Column
        title: string;

        @BelongsToMany(() => Author2, 'AuthorBook2', 'bookId', 'authorId')
        authors: Author2[];
      }

      @Table
      class Author2 extends Model<Author2> {

        @Column
        name: string;

        @BelongsToMany(() => Book2, 'AuthorBook2', 'authorId', 'bookId')
        books: Book2;
      }

      manyToManyTestSuites(Book2, Author2);
    });
  });

  describe('One-to-one', () => {

    const userWithAddress = {
      name: 'Sherlock Holmes',
      address: {
        street: 'Bakerstreet',
        city: 'London',
        zipCode: '12345',
        country: 'England',
      }
    };

    const emancipatedAddress = {
      street: 'Bakerstreet',
      city: 'London',
      zipCode: '12345',
      country: 'England',
      user: {
        name: 'hng?'
      }
    };

    const petersAddress = {
      street: '738 Winter Garden DriveForest Hills',
      city: 'New York',
      zipCode: '12345',
      country: 'United States',
    };

    const petersOtherAddress = {
      street: '137 Chrystie Street',
      city: 'New York',
      zipCode: '12345',
      country: 'United States',
    };

    function oneToOneTestSuites(User: typeof Model, Address: typeof Model): void {

      sequelize.addModels([User, Address]);

      beforeEach(() => sequelize.sync({force: true}));

      it('should create models with specified relations', () => {

        expect(User)
          .to.have.property('associations')
          .that.has.property('address')
          .that.is.an.instanceOf(Association['HasOne'])
          .and.has.property('foreignKey', 'userId')
        ;

        expect(Address)
          .to.have.property('associations')
          .that.has.property('user')
          .that.is.an.instanceOf(Association['BelongsTo'])
          .and.has.property('foreignKey', 'userId')
        ;
      });

      it('should create models with generated functions on its prototype', () => {

        expectAutoGeneratedFunctions(User, {singular: 'address'});
        expectAutoGeneratedFunctions(Address, {singular: 'user'});
      });

      describe('create()', () => {

        it('should create instances and relation between', () =>

          Promise.all([
            User.create(userWithAddress, {include: [Address]})
              .then(user => {

                assertInstance(user, userWithAddress);
              }),
            Address.create(emancipatedAddress, {include: [User]})
              .then(address => {

                assertInstance(address, emancipatedAddress);
              })
          ])
        );

        it('should create instances without relation', () =>
          User
            .create(userWithAddress)
            .then(user => {

              expect(user)
                .to.have.property('id')
                .that.is.not.null;

              expect(user)
                .not.to.have.property('address');
            })
        );
      });

      describe('findById()', () => {

        it('should find instances with related instances', () =>

          Promise.all([
            User.create(userWithAddress, {include: [Address]})
              .then(user => User.findById(user.id, {include: [Address]}))
              .then(user => {

                assertInstance(user, userWithAddress);
              }),
            Address.create(emancipatedAddress, {include: [User]})
              .then(address => Address.findById(address.id, {include: [User]}))
              .then(address => {

                assertInstance(address, emancipatedAddress);
              })
          ])
        );
      });

      describe('findOne()', () => {

        it('should find instances with related instances', () =>

          Promise.all([
            User.create(userWithAddress, {include: [Address]})
              .then(user => User.findOne({include: [Address], where: {id: user.id}}))
              .then(user => {

                assertInstance(user, userWithAddress);
              }),
            Address.create(emancipatedAddress, {include: [User]})
              .then(address => Address.findOne({include: [User], where: {id: address.id}}))
              .then(address => {

                assertInstance(address, emancipatedAddress);
              })
          ])
        );
      });

      describe('findAll()', () => {

        it('should find instances with related instances', () =>

          Promise.all([
            User.create(userWithAddress, {include: [Address]})
              .then(user => User.findAll({include: [Address], where: {id: user.id}}))
              .then(users => {

                assertInstance(users[0], userWithAddress);
              }),
            Address.create(emancipatedAddress, {include: [User]})
              .then(address => Address.findAll({include: [User], where: {id: address.id}}))
              .then(addresses => {

                assertInstance(addresses[0], emancipatedAddress);
              })
          ])
        );
      });

      describe('$get', () => {

        it('should get related instances of source instance', () =>

          Promise
            .all([
              User.create(userWithAddress, {include: [Address]})
                .then(user => User.findById(user.id))
                .then(user =>
                  user
                    .$get('address')
                    .then(address => {

                      assertInstance(address, userWithAddress.address);
                    })
                ),
              Address.create(emancipatedAddress, {include: [User]})
                .then(author => Address.findById(author.id))
                .then(author =>
                  author
                    .$get('user')
                    .then(user => {

                      assertInstance(user, emancipatedAddress.user);
                    })
                )

            ])
        );
      });

      describe('$set', () => {

        it('should set relation between specified instances and source instance', () =>

          Promise
            .all([
              User.create(elisa),
              Address.create(petersAddress)
            ])
            .then(([user, address]) =>
              user
                .$set('address', address)
                .then(() => User.findById(user.id, {include: [Address]}))
                .then(_user => {

                  assertInstance(_user, Object.assign({address: petersAddress}, elisa));
                })
            )
        );

        it('should override previous relations', () =>

          Promise
            .all([
              User.create(elisa),
              Address.create(petersAddress),
              Address.create(petersOtherAddress),
            ])
            .then(([user, address1, address2]) =>
              user
                .$set('address', address1)
                .then(() => User.findById(user.id, {include: [Address]}))
                .then(_user => {

                  assertInstance(_user, Object.assign({address: petersAddress}, elisa));
                })
                // override previous authors
                .then(() => user.$set('address', address2))
                .then(() => User.findById(user.id, {include: [Address]}))
                .then(_user => {

                  // and check, if there are overridden
                  assertInstance(_user, Object.assign({address: petersOtherAddress}, elisa));
                })
            )
        );

      });

      describe('$create', () => {

        it('should create new instance and add relation between new instance and source instance (has one)', () =>

          User.create(elisa)
            .then((user) =>
              user
                .$create('address', Object.assign({}, petersAddress))
                .then(address => {

                  assertInstance(address, petersAddress);
                })
                .then(() => User.findById(user.id, {include: [Address]}))
                .then(_user => {

                  assertInstance(_user, Object.assign({address: petersAddress}, elisa));
                })
            )
        );

        it('should create new instance and add relation between new instance and source instance (belongs to)', () =>

          Address.create(petersAddress)
            .then((address) =>
              address
                .$create('user', Object.assign({}, elisa))
                .then(() => Address.findById(address.id, {include: [User]}))
                .then(_address => {

                  assertInstance(_address, Object.assign({user: elisa}, petersAddress));
                })
            )
        );

      });

    }

    describe('resolve foreign keys automatically', () => {

      @Table
      class User extends Model<User> {

        @Column
        name: string;

        @HasOne(() => Address)
        address: any; // "any" because of order of execution (in separate classes this will work, I promise)
      }

      @Table
      class Address extends Model<Address> {

        @Column
        street: string;

        @Column
        zipCode: string;

        @Column
        city: string;

        @Column
        country: string;

        @ForeignKey(() => User)
        userId: number;

        @BelongsTo(() => User)
        user: User;
      }

      oneToOneTestSuites(User, Address);
    });

    describe('set foreign keys explicitly', () => {

      @Table
      class User2 extends Model<User2> {

        @Column
        name: string;

        @HasOne(() => Address2, 'userId')
        address: any; // "any" because of order of execution (in separate classes this will work, I promise)
      }

      @Table
      class Address2 extends Model<Address2> {

        @Column
        street: string;

        @Column
        zipCode: string;

        @Column
        city: string;

        @Column
        country: string;

        @BelongsTo(() => User2, 'userId')
        user: User2;
      }

      oneToOneTestSuites(User2, Address2);
    });
  });

});
