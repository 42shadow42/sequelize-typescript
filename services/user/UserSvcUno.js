///<reference path="../../node_modules/tsd-goalazo-models/models.d.ts"/>
///<reference path="../../typings/q/Q.d.ts"/>
///<reference path="../../typings/bcrypt/bcrypt.d.ts"/>
///<reference path="../../typings/express/express.d.ts"/>
///<reference path="../../typings/jsonwebtoken/jsonwebtoken.d.ts"/>
var CodeError_1 = require("../../uitils/CodeError");
var uuid = require('node-uuid');
var bcrypt = require('bcrypt');
var crypto = require('crypto');
var Q = require('q');
var jwt = require('jsonwebtoken');
var config_1 = require('../../config');
var UserRepoUno_1 = require("../../repositiories/user/UserRepoUno");
var UserSvcUno = (function () {
    function UserSvcUno() {
        this.userRepo = new UserRepoUno_1.UserRepoUno();
    }
    UserSvcUno.prototype.register = function (name, password) {
        var _this = this;
        var generateUserPromise;
        if (!name && !password) {
            generateUserPromise = this.userRepo.setUser(true, uuid.v1() // generate random name based on type
            );
        }
        else {
            generateUserPromise = this.hashPassword(password)
                .then(function (hashedPassword) { return _this.userRepo.setUser(false, name, hashedPassword); });
        }
        return generateUserPromise
            .then(function (user) { return _this.getAuthUser(user); });
    };
    UserSvcUno.prototype.authenticate = function (name, password) {
        var _this = this;
        return this.userRepo.getUser(name)
            .then(function (user) {
            if (!user) {
                throw new CodeError_1.CodeError('authentication failed', CodeError_1.ErrorCode.AuthenticationFailed);
            }
            if (user.isAutoGenerated) {
                return user;
            }
            if (password) {
                return _this.comparePasswordWithHashedPassword(password, user.password)
                    .then(function (isValid) {
                    if (isValid) {
                        return user;
                    }
                });
            }
            throw new CodeError_1.CodeError('authentication failed', CodeError_1.ErrorCode.AuthenticationFailed);
        })
            .then(function (user) { return _this.getAuthUser(user); });
    };
    UserSvcUno.prototype.checkAuthentication = function (token) {
        var _this = this;
        return Q.Promise(function (resolve, reject) {
            jwt.verify(token, config_1.config.jwtSecret, function (err, user) {
                if (err) {
                    reject(err);
                }
                else {
                    resolve(_this.getAuthUser(user));
                }
            });
        });
    };
    UserSvcUno.prototype.getAuthUser = function (user) {
        return {
            id: user.id,
            name: user.name,
            token: this.getToken(user),
            isAdmin: user.isAdmin,
            isAutoGenerated: user.isAutoGenerated,
            registrationDate: user.registrationDate
        };
    };
    UserSvcUno.prototype.getToken = function (user) {
        return jwt.sign(user, config_1.config.jwtSecret, {
            expiresInMinutes: 1440 // expires in 24h
        });
    };
    /**
     * password gets peppered (config.passwordPepper), hashed (sha256)
     * and salted by bcrypt
     * @param password
     * @return {Promise<string>}
     */
    UserSvcUno.prototype.hashPassword = function (password) {
        var _this = this;
        return Q.Promise(function (resolve, reject) {
            bcrypt.hash(_this.pepperPassword(password), 10, function (err, hashedPassword) {
                if (err) {
                    reject(err);
                }
                else {
                    resolve(hashedPassword);
                }
            });
        });
    };
    UserSvcUno.prototype.pepperPassword = function (password) {
        return crypto.createHash('sha256').update(password + config_1.config.passwordPepper).digest('base64');
    };
    UserSvcUno.prototype.comparePasswordWithHashedPassword = function (password, hashedPassword) {
        var _this = this;
        return Q.Promise(function (resolve, reject) {
            bcrypt.compare(_this.pepperPassword(password), hashedPassword, function (err, isValid) {
                if (err) {
                    reject(err);
                }
                else {
                    resolve(isValid);
                }
            });
        });
    };
    return UserSvcUno;
})();
exports.UserSvcUno = UserSvcUno;
//# sourceMappingURL=UserSvcUno.js.map