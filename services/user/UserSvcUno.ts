///<reference path="../../node_modules/tsd-goalazo-models/models.d.ts"/>
///<reference path="../../typings/q/Q.d.ts"/>
///<reference path="../../typings/bcrypt/bcrypt.d.ts"/>
///<reference path="../../typings/express/express.d.ts"/>
///<reference path="../../typings/jsonwebtoken/jsonwebtoken.d.ts"/>

import isMatchCustomizer = _.isMatchCustomizer;
var generatePassword = require('password-generator');
var uuid = require('node-uuid');
import express = require('express');
import bcrypt = require('bcrypt');
import crypto = require('crypto');
import Q = require('q');
import jwt = require('jsonwebtoken');
import {config} from '../../config';
import {IUserInstance} from "../../typings/custom/models";
import {UserRepoUno} from "../../repositiories/user/UserRepoUno";
import Promise = Q.Promise;
import IUser = goalazo.IUser;

export class UserSvcUno {

    protected userRepo: UserRepoUno;

    constructor() {
        this.userRepo = new UserRepoUno();
    }

    register(name?: string, password?: string): Promise<IUser> {
        var generateUserPromise: Promise<IUser>;

        if (!name && !password) {

            generateUserPromise = this.userRepo.setUser(
                true,
                uuid.v1() // generate random name based on type
            );
        } else {

            generateUserPromise = this.hashPassword(password)
                .then((hashedPassword) => this.userRepo.setUser(false, name, hashedPassword));
        }

        return generateUserPromise
            .then((user: IUser) => {

                user.token = this.getToken(user);

                return user;
            })
    }

    authenticate(name: string, password: string): Promise<IUser> {

        return this.userRepo.getUser(name)
            .then((user: IUser) => {

                if (!user) {

                    throw new Error('');
                }

                user.token = this.getToken(user);

                if (user.isAutoGenerated) {

                    return user;
                }

                if (password) {

                    return this.comparePasswordWithHashedPassword(password, user.password)
                        .then((isValid) => {

                            if(isValid) {

                                return user;
                            }
                        });
                } else {

                    throw new Error('');
                }

            });
    }

    protected getToken(user: IUser) {

        return jwt.sign(user, config.jwtSecret, {
            expiresInMinutes: 1440 // expires in 24h
        });
    }

    /**
     * password gets peppered (config.passwordPepper), hashed (sha256)
     * and salted by bcrypt
     * @param password
     * @return {Promise<string>}
     */
    protected hashPassword(password: string): Promise<string> {

        return Q.Promise<string>((resolve, reject) => {

            bcrypt.hash(this.pepperPassword(password), 10, (err: Error, hashedPassword: string) => {

                if (err) {

                    reject(err);
                } else {

                    resolve(hashedPassword);
                }
            })
        });
    }

    private pepperPassword(password: string) {

        return crypto.createHash('sha256').update(password + config.passwordPepper).digest('base64');
    }

    protected comparePasswordWithHashedPassword(password, hashedPassword): Promise<boolean> {

        return Q.Promise<boolean>((resolve, reject) => {

            bcrypt.compare(this.pepperPassword(password), hashedPassword, (err: Error, isValid: boolean) => {

                if (err) {

                    reject(err);
                } else {

                    resolve(isValid);
                }
            });
        });

    }
}
