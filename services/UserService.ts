import {NotAuthorizedError} from "../errors/NotAuthorizedError";
import {User} from "../models/User";
import {UniqueConstraintError} from "sequelize";
import {UserAlreadyExistsError} from "../errors/UserAlreadyExistsError";
import {Inject} from 'di-ts'
import {config} from '../config';
import express = require('express');
import bcrypt = require('bcrypt');
import crypto = require('crypto');
import Promise = require('bluebird');
import jwt = require('jsonwebtoken');
import {db} from "../db";
import {UserNotFoundError} from "../errors/UserNotFoundError";
import {OICPHelper} from "./OICPHelper";
import {SoapService} from "./SoapService";
import {IMobileAuthorizationStart} from "../interfaces/soap/IMobileAuthorizationStart";
import {InvalidDataError} from "../errors/InvalidDataError";
const uuid = require('node-uuid');


@Inject
export class UserService {

  constructor(protected oicpHelper: OICPHelper,
              protected soapService: SoapService) {
  }

  /**
   * Registers if user not exists, otherwise user will be authenticated
   */
  registerOrAuthenticate(languageCode: string, evcoId?: string, password?: string): Promise<User> {

    return db.model(User)
      .findOne({where: {evcoId}})
      .then(user => {

        if (user) {

          return this.authenticate(evcoId, password);
        }

        return this.register(languageCode, evcoId, password);
      })
      ;
  }

  /**
   * Authorizes the specified credentials by sending a soap request to hbs;
   * If authorized, a user will be created
   */
  register(languageCode: string, evcoId: string, password: string): Promise<User> {

    return this.authenticateWithHbs(evcoId, password)
      .then(() => this.hashPassword(password))
      .then((hashedPassword) => db.model(User)
        .create<IUser>({
          providerId: this.oicpHelper.getProviderId(evcoId),
          evcoId,
          password: hashedPassword,
          isAutoGenerated: false,
          languageCode
        }))
      .catch(UniqueConstraintError, err => Promise.reject(new UserAlreadyExistsError(evcoId)))
      .then((user: User) => this.getAuthUser(user))
      ;
  }

  /**
   * Creates an auto generated user
   */
  registerAutoGenerated(languageCode: string) {

    return db.model(User)
      .create<IUser>({
        code: uuid.v1(), // generate random code
        isAutoGenerated: true,
        languageCode
      })
      .then((user: User) => this.getAuthUser(user))
      ;
  }

  /**
   * Converts an auto generated user to a non-auto generated user by
   * setting value for evcoId and password and false for isAutoGenerated
   */
  convertToNonAutoGenerated(code: string, evcoId: string, password: string) {

    return db.model(User)
      .findOne({where: {code}})
      .then((user: User) => {

        if (!user) {

          throw new UserNotFoundError();
        }

        // check if user is an auto generated user
        if (!user.isAutoGenerated) {

          throw new NotAuthorizedError('User is already an non auto generated user');
        }

        return this.authenticateWithHbs(evcoId, password)
          .then(() => this.hashPassword(password))
          .then((hashedPassword) => {

            user.providerId = this.oicpHelper.getProviderId(evcoId);
            user.evcoId = evcoId;
            user.password = hashedPassword;
            user.isAutoGenerated = false;
            user.code = null;

            return user.save();
          })
          .catch(UniqueConstraintError, err => Promise.reject(new UserAlreadyExistsError(evcoId)))
          ;
      })
      ;
  }

  /**
   * Updates specified user and specified fields
   *
   * NOTICE: Currently only languageCode can be updated
   */
  update(user: IUser, fields: any) {

    return db.model(User)
      .update(fields, {
        fields: ['languageCode'],
        where: {id: user.id}
      })
      ;
  }

  /**
   * Authenticates user specified by code/evcoId and password
   */
  authenticate(code_evcoId: string, password?: string): Promise<User> {

    return db.model(User)
      .scope(false) // by default password will not be retrieved, that's why we set scope false
      .findOne<User>({
        where: {$or: [{code: code_evcoId}, {evcoId: code_evcoId}]}
      })
      .then(user => {

        if (!user) {
          throw new NotAuthorizedError(`Authentication failed for user ${name}`);
        }

        if (user.isAutoGenerated) {
          return user;
        }

        if (password) {

          return this.comparePasswordWithHashedPassword(password, user.password)
            .then((isValid) => {

              if (isValid) {
                return user;
              }

              throw new NotAuthorizedError(`Authentication failed for user ${name}`);
            });
        }

        throw new NotAuthorizedError(`Authentication failed for user ${name}`);
      })
      .then(user => this.getAuthUser(user))
      ;
  }

  /**
   * Authenticates user by specified token
   */
  checkAuthentication(token: string): Promise<User> {

    return new Promise<User>((resolve, reject) => {

      jwt.verify(token, config.jwtSecret, (err, user) => {

        if (err) {

          reject(new NotAuthorizedError(err.message));
        } else {

          resolve(user);
        }
      });
    });
  }

  /**
   * Authorizes user by validating evco id and sending soap request to hbs
   * @throws InvalidDataError if evco id is invalid
   * @throws NotAuthorizedError if hbs responses with another status than 'Authorized'
   */
  protected authenticateWithHbs(evcoId: string, password: string) {

    const SUCCESS_STATUS = 'Authorized';

    return Promise.resolve()
      .then(() => this.oicpHelper.validateEvcoId(evcoId))
      .then(isValid => {

        if (!isValid) {

          throw new InvalidDataError('Specified EVCOID is not valid');
        }
      })
      .then(() => this.soapService.eRoamingMobileAuthorizeStart(evcoId, password))
      .then((mobileAuthStart: IMobileAuthorizationStart) => {

        if (mobileAuthStart.AuthorizationStatus !== SUCCESS_STATUS) {

          throw new NotAuthorizedError('EVCOID or password are not valid');
        }
      })
      ;
  }

  /**
   * Stores token to specified user and removes password
   */
  protected getAuthUser(user: User): User {

    delete user.dataValues.password;

    user.token = this.createToken(user.dataValues);

    return user;
  }

  /**
   * Removes password from user object
   */
  protected removePassword(user: User) {

    delete user.dataValues.password;
  }

  /**
   * Creates a token for specified user
   */
  protected createToken(user: User): string {

    return jwt.sign(user, config.jwtSecret, {
      expiresInMinutes: config.jwtExpiresIn
    });
  }

  /**
   * password gets peppered (config.passwordPepper), hashed (sha256)
   * and salted by bcrypt
   */
  protected hashPassword(password: string): Promise<string> {

    const ROUNDS = 10;

    return new Promise<string>((resolve, reject) => {

      bcrypt.hash(this.pepperPassword(password), ROUNDS, (err: Error, hashedPassword: string) => {

        if (err) {

          reject(err);
        } else {

          resolve(hashedPassword);
        }
      })
    });
  }

  /**
   * Compared specified password with specified hashed password
   */
  protected comparePasswordWithHashedPassword(password, hashedPassword): Promise<boolean> {

    return new Promise<boolean>((resolve, reject) => {

      bcrypt.compare(this.pepperPassword(password), hashedPassword, (err: Error, isValid: boolean) => {

        if (err) {

          reject(err);
        } else {

          resolve(isValid);
        }
      });
    });

  }

  /**
   * Adds an configured pepper to the specified password
   */
  protected pepperPassword(password: string) {

    return crypto.createHash('sha256').update(password + config.passwordPepper).digest('base64');
  }
}
