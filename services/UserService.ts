import {AuthenticationFailedError} from "../errors/AuthenticationFailedError";
import {NotAuthorizedError} from "../errors/NotAuthorizedError";
import {User} from "../models/User";
import {UniqueConstraintError} from "sequelize";
import {UserAlreadyExistsError} from "../errors/UserAlreadyExistsError";
import {Inject} from 'di-ts'
import {config} from '../config';
import express = require('express');
import bcrypt = require('bcrypt');
import crypto = require('crypto');
import Promise = require('bluebird');
import jwt = require('jsonwebtoken');
import {db} from "../db";
const uuid = require('node-uuid');

@Inject
export class UserService {

  constructor() {
  }

  /**
   * Registers a new user. If neither name or password is provided,
   * an auto generated user is created.
   */
  register(languageCode: string, evcoId?: string, password?: string): Promise<User> {

    return db.sequelize.transaction(transaction => {
      let generateUserPromise: Promise<User|IUser>;

      if (!evcoId && !password) {

        // create auto generated user with random code
        generateUserPromise = db.model(User)
          .create<IUser>({
            code: uuid.v1(), // generate random code
            isAutoGenerated: true,
            languageCode
          }, {transaction});
      } else {

        // create user
        generateUserPromise = this
          .hashPassword(password)
          .then((hashedPassword) => db.model(User)
            .create<IUser>({
              evcoId,
              password: hashedPassword,
              isAutoGenerated: false,
              languageCode
            }, {transaction}))
          .catch(UniqueConstraintError, err => Promise.reject(new UserAlreadyExistsError(evcoId)))
        ;
      }

      return (generateUserPromise as any)
        .then((user: User) => this.getAuthUser(user))
        ;
    });
  }

  update(user: IUser, fields: any) {

    return db.model(User)
      .update(fields, {
        fields: ['languageCode'],
        where: {id: user.id}
      })
    ;
  }

  /**
   * Converts auto generated user to non auto generated user.
   */
  convert(evcoId: string, code: string, password: string) {

    return db.model(User)
      .findOne<User>({where: {code}})
      .then(user => {

        if (!user) {

          throw new NotAuthorizedError('User not found');
        }

        // check if user is an auto generated user
        if (!user.isAutoGenerated) {

          throw new NotAuthorizedError('User is already an non auto generated user');
        }

        const isAutoGenerated = false;

        return this.hashPassword(password)
          .then(password => {

            return db.model(User).insertOrUpdate<IUser>({isAutoGenerated, evcoId, password});
          })
      })
      ;
  }

  /**
   * Authenticates user specified by code/evcoId and password
   */
  authenticate(code_evcoId: string, password?: string): Promise<User> {

    return db.model(User)
      .scope(false)// by default password will not be retrieved, that's why we set scope false
      .findOne<User>({
        where: {$or: [{code: code_evcoId}, {evcoId: code_evcoId}]}
      })
      .then(user => {

        if (!user) {
          throw new AuthenticationFailedError(`Authentication failed for user ${name}`);
        }

        if (user.isAutoGenerated) {
          return user;
        }

        if (password) {

          return this.comparePasswordWithHashedPassword(password, user.password)
            .then((isValid) => {

              if (isValid) {
                return user;
              }

              throw new AuthenticationFailedError(`Authentication failed for user ${name}`);
            });
        }

        throw new AuthenticationFailedError(`Authentication failed for user ${name}`);
      })
      .then(user => this.getAuthUser(user))
      ;
  }

  /**
   * Authenticates user by specified token
   */
  checkAuthentication(token: string): Promise<User> {

    return new Promise<User>((resolve, reject) => {

      jwt.verify(token, config.jwtSecret, (err, user) => {

        if (err) {

          reject(new NotAuthorizedError(err.message));
        } else {

          resolve(user);
        }
      });
    });
  }

  /**
   *
   */
  protected getAuthUser(user: User): User {

    delete user.dataValues.password;

    user.token = this.createToken(user.dataValues);

    return user;
  }

  /**
   * Removes password from user object
   */
  protected removePassword(user: User) {

    delete user.dataValues.password;
  }

  /**
   * Creates a token for specified user
   */
  protected createToken(user: User): string {

    return jwt.sign(user, config.jwtSecret, {
      expiresInMinutes: config.jwtExpiresIn
    });
  }

  /**
   * password gets peppered (config.passwordPepper), hashed (sha256)
   * and salted by bcrypt
   * @param password
   * @return {Promise<string>}
   */
  protected hashPassword(password: string): Promise<string> {

    const ROUNDS = 10;

    return new Promise<string>((resolve, reject) => {

      bcrypt.hash(this.pepperPassword(password), ROUNDS, (err: Error, hashedPassword: string) => {

        if (err) {

          reject(err);
        } else {

          resolve(hashedPassword);
        }
      })
    });
  }

  /**
   * Compared specified password with specified hashed password
   */
  protected comparePasswordWithHashedPassword(password, hashedPassword): Promise<boolean> {

    return new Promise<boolean>((resolve, reject) => {

      bcrypt.compare(this.pepperPassword(password), hashedPassword, (err: Error, isValid: boolean) => {

        if (err) {

          reject(err);
        } else {

          resolve(isValid);
        }
      });
    });

  }

  /**
   * Adds an configured pepper to the specified password
   */
  protected pepperPassword(password: string) {

    return crypto.createHash('sha256').update(password + config.passwordPepper).digest('base64');
  }
}
