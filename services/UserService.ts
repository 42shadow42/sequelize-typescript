import {NotAuthorizedError} from "../errors/NotAuthorizedError";
import {User} from "../models/User";
import {UniqueConstraintError} from "sequelize";
import {UserAlreadyExistsError} from "../errors/UserAlreadyExistsError";
import {Inject} from 'di-ts'
import {config} from '../config';
import express = require('express');
import bcrypt = require('bcrypt');
import crypto = require('crypto');
import Promise = require('bluebird');
import jwt = require('jsonwebtoken');
import {db} from "../db";
import {UserNotFoundError} from "../errors/UserNotFoundError";
import {OICPHelper} from "./OICPHelper";
import {SoapService} from "./SoapService";
import {IMobileAuthorizationStart} from "../interfaces/soap/IMobileAuthorizationStart";
import {InvalidDataError} from "../errors/InvalidDataError";
const uuid = require('node-uuid');


@Inject
export class UserService {

  constructor(protected oicpHelper: OICPHelper,
              protected soapService: SoapService) {
  }

  /**
   * Gets full user including hashed password(!)
   */
  getFullUser(code_evcoId: string): Promise<User> {

    return db.model(User)
      .scope(false) // by default password will not be retrieved, that's why we set scope false
      .findOne<User>({
        where: {$or: [{code: code_evcoId}, {evcoId: code_evcoId}]}
      })
    ;
  }

  /**
   * Registers if user not exists, otherwise user will be authenticated
   */
  registerOrAuthenticate(languageCode: string, providerId: string, evcoId: string, password: string): Promise<User> {

    return this.getFullUser(evcoId)
      .then(user => {

        if (user) {

          // TODO consider what happens, if password has changed

          return this.authenticate(user, password);
        }

        return this.register(languageCode, providerId, evcoId, password);
      })
      ;
  }

  /**
   * Registers depending on the specified parameters an auto generated user
   * or a normal one
   */
  register(languageCode: string, providerId: string, evcoId?: string, password?: string) {

    if(!evcoId && !password) {

      return this.createAutoGenerated(languageCode, providerId);
    } else if (evcoId && password) {

      return this.create(languageCode, evcoId, password);
    }

    throw new InvalidDataError('Either evco id and password has to be specified or none of them');
  }

  /**
   * If password for hbs has changed, this is the functionality for
   * updating the password in this system
   */
  updatePassword(user: IUser, newPassword: string) {

    return this.authenticateWithHbs(user.evcoId, newPassword)
      .then(() => this.hashPassword(newPassword))
      .then(hashedPassword => db.model(User)
        .update(
          {password: newPassword},
          {where: {evcoId: user.evcoId}}
        )
      )
    ;
  }

  /**
   * Converts an auto generated user to a non-auto generated user
   * or if a user with the specified evcoId already exists,
   * authenticates this user and resolves with the evco user
   */
  loginFromAutoGenerated(code: string, evcoId: string, password: string) {

    return Promise.all([
      db.model(User).findOne({where: {code}}),
      this.getFullUser(evcoId),
    ])
      .then((users: User[]) => {
        const [autoGeneratedUser, evcoUser] = users;

        if (!autoGeneratedUser && !evcoUser) {

          throw new UserNotFoundError();
        }

        // check if user is an auto generated user
        if (!autoGeneratedUser.isAutoGenerated) {

          throw new NotAuthorizedError('User is already an non auto generated user');
        }

        if(evcoUser) {

          return this.authenticate(evcoUser, password);
        }

        return this.convertToNonAutoGenerated(autoGeneratedUser, evcoId, password);
      })
      ;
  }

  /**
   * Converts an auto generated user to a non-auto generated user by
   * setting value for evcoId and password and false for isAutoGenerated
   */
  convertToNonAutoGenerated(autoGeneratedUser: User, evcoId: string, password: string) {

    return Promise.resolve()
      .then(() => {

        // check if user is an auto generated user
        if (!autoGeneratedUser.isAutoGenerated) {

          throw new NotAuthorizedError('User is already an non auto generated user');
        }

        return this.authenticateWithHbs(evcoId, password)
          .then(() => this.hashPassword(password))
          .then((hashedPassword) => {

            autoGeneratedUser.providerId = this.oicpHelper.getProviderId(evcoId);
            autoGeneratedUser.evcoId = evcoId;
            autoGeneratedUser.password = hashedPassword;
            autoGeneratedUser.isAutoGenerated = false;
            autoGeneratedUser.code = null;

            return autoGeneratedUser.save();
          })
          .catch(UniqueConstraintError, err => Promise.reject(new UserAlreadyExistsError(evcoId)))
          ;
      })
      ;
  }

  /**
   * Updates specified user and specified fields
   *
   * NOTICE: Currently only languageCode can be updated
   */
  update(user: IUser, fields: any) {

    return db.model(User)
      .update(fields, {
        fields: ['languageCode'],
        where: {id: user.id}
      })
      ;
  }

  /**
   * Authenticates user specified by code/evcoId and password
   */
  authenticate(user?: User, password?: string): Promise<User> {

    return Promise.resolve()
      .then(() => {

        if (!user) {
          throw new UserNotFoundError();
        }

        if (user.isAutoGenerated) {
          return user;
        }

        if (password) {

          return this.comparePasswordWithHashedPassword(password, user.password)
            .then((isValid) => {

              if (isValid) {
                return user;
              }

              throw new NotAuthorizedError(`Authentication failed`);
            });
        }

        throw new NotAuthorizedError(`Authentication failed`);
      })
      .then(user => this.getAuthUser(user))
      ;
  }

  /**
   * Authenticates user by specified token
   */
  checkAuthentication(token: string): Promise<User> {

    return new Promise<User>((resolve, reject) => {

      jwt.verify(token, config.jwtSecret, (err, user) => {

        if (err) {

          reject(new NotAuthorizedError(err.message));
        } else {

          resolve(user);
        }
      });
    });
  }

  /**
   * Authorizes the specified credentials by sending a soap request to hbs;
   * If authorized, a user will be created
   */
  protected create(languageCode: string, evcoId: string, password: string): Promise<User> {

    return this.authenticateWithHbs(evcoId, password)
      .then(() => this.hashPassword(password))
      .then((hashedPassword) => db.model(User)
        .create<IUser>({
          providerId: this.oicpHelper.getProviderId(evcoId),
          evcoId,
          password: hashedPassword,
          isAutoGenerated: false,
          languageCode
        }))
      .catch(UniqueConstraintError, err => Promise.reject(new UserAlreadyExistsError(evcoId)))
      .then((user: User) => this.getAuthUser(user))
      ;
  }

  /**
   * Creates an auto generated user
   */
  protected createAutoGenerated(languageCode: string, providerId?: string) {

    return db.model(User)
      .create<IUser>({
        code: uuid.v1(), // generate random code
        isAutoGenerated: true,
        languageCode,
        providerId
      })
      .then((user: User) => this.getAuthUser(user))
      ;
  }

  /**
   * Authorizes user by validating evco id and sending soap request to hbs.
   * HBS tells us, whether user is authorized or not
   *
   * @throws InvalidDataError if evco id is invalid
   * @throws NotAuthorizedError if hbs responses with another status than 'Authorized'
   */
  protected authenticateWithHbs(evcoId: string, password: string) {

    const SUCCESS_STATUS = 'Authorized';

    return Promise.resolve()
      .then(() => this.oicpHelper.validateEvcoId(evcoId))
      .then(isValid => {

        if (!isValid) {

          throw new InvalidDataError('Specified EVCOID is not valid');
        }
      })
      .then(() => this.soapService.eRoamingMobileAuthorizeStart(evcoId, password))
      .then((mobileAuthStart: IMobileAuthorizationStart) => {

        if (!mobileAuthStart || mobileAuthStart.AuthorizationStatus !== SUCCESS_STATUS) {

          throw new NotAuthorizedError('EVCOID or password is not valid');
        }
      })
      ;
  }

  /**
   * Stores token to specified user and removes password
   */
  protected getAuthUser(user: User): User {

    delete user.dataValues.password;

    user.token = this.createToken(user.dataValues);

    return user;
  }

  /**
   * Removes password from user object
   */
  protected removePassword(user: User) {

    delete user.dataValues.password;
  }

  /**
   * Creates a token for specified user
   */
  protected createToken(user: User): string {

    return jwt.sign(user, config.jwtSecret, {
      expiresInMinutes: config.jwtExpiresIn
    });
  }

  /**
   * password gets peppered (config.passwordPepper), hashed (sha256)
   * and salted by bcrypt
   */
  protected hashPassword(password: string): Promise<string> {

    const ROUNDS = 10;

    return new Promise<string>((resolve, reject) => {

      bcrypt.hash(this.pepperPassword(password), ROUNDS, (err: Error, hashedPassword: string) => {

        if (err) {

          reject(err);
        } else {

          resolve(hashedPassword);
        }
      })
    });
  }

  /**
   * Compared specified password with specified hashed password
   */
  protected comparePasswordWithHashedPassword(password, hashedPassword): Promise<boolean> {

    return new Promise<boolean>((resolve, reject) => {

      bcrypt.compare(this.pepperPassword(password), hashedPassword, (err: Error, isValid: boolean) => {

        if (err) {

          reject(err);
        } else {

          resolve(isValid);
        }
      });
    });

  }

  /**
   * Adds an configured pepper to the specified password
   */
  protected pepperPassword(password: string) {

    return crypto.createHash('sha256')
      .update(password + config.passwordPepper)
      .digest('base64')
      ;
  }
}
